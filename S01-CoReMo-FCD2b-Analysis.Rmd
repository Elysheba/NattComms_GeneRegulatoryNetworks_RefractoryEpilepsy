---
title: "Systematic transcriptional investigation of epilepsy associated structural abnormalities: towards the identification of novel treatment targets"
subtitle: "Coregulated gene modules identification in FCD 2b"
author: "Liesbeth Fran√ßois"
date: "`r format(Sys.time(), '%B %d %Y')`"
output: 
   html_document: 
     self_contained: yes
     fig_height: 6
     fig_width: 8
     keep_md: yes
     number_sections: yes
     theme: cerulean
     toc: yes
     toc_float: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, echo=F, eval = T, include=F}
rm(list=ls())
gc() 
library(knitr)
library(kableExtra)
opts_chunk$set(
   include=FALSE,
   warning=FALSE, echo=FALSE, message=FALSE,
   concordance=TRUE
)
##
library(beeswarm)
library(BiocParallel)
library(DT)
library(edgeR)
library(ggplot2)
library(here)
library(limma)
library(MASS)
library(openxlsx)
library(plotly)
library(RColorBrewer)
library(readxl)
library(scales)
library(tibble)
library(tximport)
library(CRAFT)
library(reshape2)
library(WGCNA)
library(GraphAT)
library(ggrepel)
library(UpSetR)
library(cluster)
library(gplots)
library(pheatmap)
library(CoReMo)
library(lme4)
library(ggpubr)
library(rlist)
library(TBTools)
library(dplyr)
library(BED)
library(RTBKM)
library(fgsea)

myPal = function(n=10){
  #returns n colors
  seq = rev(seq(0,255,by=255/(n)))
  palRGB = cbind(seq,seq,255)
  rgb(palRGB,maxColorValue=255)
}
bigFormat <- function(n){
   format(n, big.mark="&nbsp;")
}

```


# Correction for technical covariates

Before applying the CoReMo analyses, the impact of technical covariates is assessed on the control and FCD 2b samples together as well as only on the FCD 2b samples. If any technical covariates are found to impact gene expression (as identified by PCA, table below), a batch correction is necessary as they may also influence the module identification workflow.

```{r , echo=F, eval = T, include=F}
load(here("Data/04_QC/Preprocessing.rda"))
sampleInfo <- sampleInfo %>% 
    filter(PA_Diagnosis %in% c("Control", "FCD 2b") & 
             Area_of_Resection %in% c("Frontal", "Occipital", 
                                      "Parietal", "Temporal")) %>%
  mutate(log10_seizure_freq = log10(Seizure_Frequency_months))
all_samples <- sampleInfo
d <- vg$E[,sampleInfo$GS_RNASEQ_ID]
```



```{r, include = TRUE}
pca <- prcomp(t(d), center=TRUE, scale.=TRUE)
pcImp <- pca$sdev^2/sum(pca$sdev^2)

## Library prep batches
pcLib <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$Library_Prep_batch[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## sgid
pcsgid <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$SGID[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## Tissue
pcArea <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$Area_of_Resection[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## Condition
pcDiag <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$PA_Diagnosis[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")

toShow<-data.frame(cbind(pcLib,pcDiag,pcArea))

datatable(
   toShow,
   filter = "top",
   options=list(pageLength=6)) %>%
 formatSignif(2, digits=3) %>%
 formatSignif(1:ncol(toShow), digits=2) %>%
 formatStyle(1:ncol(toShow),
             backgroundColor=styleInterval(c(10^(-6), 0.05),
                                           colorRampPalette(c("darkred",
                                                              "white"))(3)),
             color=styleInterval(10^(-6), c("white", "black")))
```

The PCA shows the impact of library preparation batch due to "Library preparation batch A" where the control samples are not matched by FCD 2b samples. Removing these 3 control samples removed the impact of library preparation batch on the PCA.

```{r, include = TRUE}
kable(table(all_samples$PA_Diagnosis, all_samples$Library_Prep_batch)) %>%
  kable_styling(latex_options = "striped")
```

```{r, include = TRUE}
p <- c(19,17)
names(p) <- c("Control", "FCD 2b")
SeqBatchCol <- brewer.pal(n = length(unique(sampleInfo$Library_Prep_batch)),name = "Set1")
names(SeqBatchCol) <- unique(sampleInfo$Library_Prep_batch)
plot(
   pca$x[,c(1,3)],
   col=SeqBatchCol[sampleInfo$Library_Prep_batch[match(rownames(pca$x),
                                                       sampleInfo$GS_RNASEQ_ID)]],
   pch=p[sampleInfo$PA_Diagnosis[match(rownames(pca$x), sampleInfo$GS_RNASEQ_ID)]],
   xlab=sprintf("PC1 (%s%s)", round(pcImp[1]*100, 1), "%"),
   ylab=sprintf("PC3 (%s%s)", round(pcImp[3]*100, 1), "%")
)
legend(
   "topleft",
   names(SeqBatchCol),
   col=SeqBatchCol[sort(names(SeqBatchCol))],
   pch=19,
   ncol=2,title = "Library prep batches"
)
```

```{r , echo=F, eval = T, include=F}
load(here("Data/04_QC/Preprocessing.rda"))
sampleInfo <- sampleInfo %>% 
    filter(PA_Diagnosis %in% c("Control", "FCD 2b") & 
             Area_of_Resection %in% c("Frontal", "Occipital", "Parietal", "Temporal")) %>%
    filter(Library_Prep_batch != "A") %>% ## no FCD 2b samples occurs in library batch A
  mutate(log10_seizure_freq = log10(Seizure_Frequency_months))
all_samples <- sampleInfo
d <- vg$E[,sampleInfo$GS_RNASEQ_ID]
```


```{r, include = FALSE}
pca <- prcomp(t(d), center=TRUE, scale.=TRUE)
pcImp <- pca$sdev^2/sum(pca$sdev^2)

## Library prep batches
pcLib <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$Library_Prep_batch[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## sgid
pcsgid <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$SGID[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## Tissue
pcArea <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$Area_of_Resection[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
## Condition
pcDiag <- p.adjust(apply(
   pca$x, 2,
   function(pc){
     head(pc)
      toTest <- data.frame(
         val=pc,
         groups=as.factor(sampleInfo$PA_Diagnosis[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)])
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")

toShow<-data.frame(cbind(pcLib,pcsgid, pcDiag,pcArea))

datatable(
   toShow,
   options=list(pageLength=20,searchable=F)
) %>%
   formatSignif(2, digits=3) %>%
   formatSignif(1:ncol(toShow), digits=2) %>%
   formatStyle(
      1:ncol(toShow),
      backgroundColor=styleInterval(
         c(10^(-6), 0.05), colorRampPalette(c("darkred", "white"))(3)
      ),
      color=styleInterval(
         10^(-6), c("white", "black")
      )
   )
```

```{r, include = FALSE}
p <- c(19,17)
names(p) <- c("Control", "FCD 2b")
SeqBatchCol <- brewer.pal(n = length(unique(sampleInfo$Library_Prep_batch)),name = "Set1")
names(SeqBatchCol) <- unique(sampleInfo$Library_Prep_batch)
par(mfrow=c(2,1), mar=c(4.1, 4.1, 1.1, 1.1))
plot(
   pca$x[,1:2],
   col=SeqBatchCol[sampleInfo$Library_Prep_batch[match(rownames(pca$x),sampleInfo$GS_RNASEQ_ID)]],
   pch=p[sampleInfo$PA_Diagnosis[match(rownames(pca$x), sampleInfo$GS_RNASEQ_ID)]],
   xlab=sprintf("PC1 (%s%s)", round(pcImp[3]*100, 1), "%"),
   ylab=sprintf("PC2 (%s%s)", round(pcImp[4]*100, 1), "%")
)
plot(
   pca$x[,c(1,3)],
   col=SeqBatchCol[sampleInfo$Library_Prep_batch[match(rownames(pca$x),
                                                       sampleInfo$GS_RNASEQ_ID)]],
   pch=p[sampleInfo$PA_Diagnosis[match(rownames(pca$x), sampleInfo$GS_RNASEQ_ID)]],
   xlab=sprintf("PC1 (%s%s)", round(pcImp[1]*100, 1), "%"),
   ylab=sprintf("PC3 (%s%s)", round(pcImp[3]*100, 1), "%")
)
```


# Identification of modules of gene co-expression in hippocampal sclerosis

This reports deals with the identification of modules of gene coregulation in hippocampal sclerosis and assessment of the conservation of the identified regulations in other contexts. As explored in the [previous report](S03-Explore-Study-Design), the coregulation modules will be build within each condition with sufficient amount of samples and within each tissue to avoid interference of tissue-specific regulations. For focal cortical dysplasia 2b (FCD 2b) there are `r sampleInfo %>% filter(PA_Diagnosis == "FCD 2b") %>% nrow()` samples. As similar regulations were identified considering only the samples from frontal cortex (21 samples) or all samples from FCD 2b (33 samples) and the expression profile across these tissues within FCD 2b overlaps strongly, the modules were constructed using all available samples for FCD 2b. This results in 33 samples with, 21 samples from frontal cortex, 2 samples from occipital cortex, 4 samples from parietal cortex, and 6 samples from temporal cortex.

A detailed explanation of the identification of gene co-expression modules can be found in [Srivastava et al. 2018](https://www.nature.com/articles/s41467-018-06008-4) or the Epinet project. Briefly, the different steps consist of: 
<ol>
<li> Differential expression analysis on gene level between  </li>
<li> Gene filtering based on variance in expression in hippocampal sclerosis </li>
<li> Scale-free fit index </li>
<li> Unsupervised hierarchical clustering and defining the optimal number of clusters </li>
<li> Module robustness assessment </li>
<li> Module overview and association to phenotype </li>
<li> Functionally annotation of the modules </li>
<li> Assessment of conservation in other pathologies and contexts to understand the functions of the module in the broader context of epilepsy and identify potential specific regulations </li>
<li> Differential co-expression of modules compared to control samples </li>
<li> Causal reasoning for prediction of upstream regulators </li>
</ol>


##  Differential expression analysis on gene level between FCD 2b and control samples

```{r deg, cache=FALSE,echo=FALSE}
resFile <- here("Data/06_Modules/FCD2b/Module-Data","DEG.rda")

if(file.exists(resFile)){
 load(resFile)
}else{
  ## design, timepoint as fixed effect
  dd <- vg$E[,pull(sampleInfo, GS_RNASEQ_ID)]
  dim(dd)
  combn <- factor(gsub(" ", "" , sampleInfo$PA_Diagnosis))
  ##
  design <- model.matrix( ~ 0 + combn)
  colnames(design) <- levels(combn)
  dim(design)
  
  ## lm
  fit <- lmFit(object = dd,
               design = design)
  ##
  contrast.matrix <- makeContrasts(FCD2b-Control, levels = design)
  fit2 <- contrasts.fit(fit, contrast.matrix)
  fit2 <- eBayes(fit2)
  deg <- topTable(fit = fit2, coef = 1, number = Inf)
  rm(combn, design, fit, contrast.matrix, fit2)
  save(deg, file=resFile)
}
```

```{r, include = TRUE}
gd <- getBeIdDescription(rownames(deg),
                         be = "Gene",
                         source = "Ens_gene",
                         organism = "human")
toShow <- deg %>%
  mutate(Gene = gd$symbol[match(rownames(deg), gd$id)])
datatable(toShow %>% 
            # slice(1:1000) %>%
            select(Gene, AveExpr, logFC, FDR = adj.P.Val),
          rownames = FALSE, 
          filter = "top") %>%
  formatSignif(c("AveExpr","logFC", "FDR"), 2)
```


## Gene filtering depending on variance 

```{r mad,echo=FALSE}
sampleInfo <- sampleInfo %>% filter(PA_Diagnosis == "FCD 2b")
d <- vg$E[, pull(sampleInfo, GS_RNASEQ_ID)]
sdThr <- 0.25
MAD <- apply(d,1,function(x) mad(x))
```

For the construction of co-expression modules only genes showing high variance across
the samples are kept for clustering analysis. Standard deviation has been
estimated using the median absolute deviation (MAD) in order to avoid outlier
triggered bias. Before MAD filtering there were `r bigFormat(nrow(d))` genes in the dataset. 

The figure below shows the distribution of gene expression MAD
across all samples.

```{r mad_plot, include=TRUE,echo=FALSE, fig.height=5}
hist(
  MAD, breaks=100,
  col="grey",
  xlab="MAD",
  main="MAD of gene expression"
)
abline(v=sdThr, col="red", lty=2, lwd=2)
```

```{r}
KeptProbes <- names(MAD)[which(MAD >= sdThr)]
length(KeptProbes)
save(KeptProbes, 
     file = here("Data","06_Modules/FCD2b/Module-Data", "List-KeptProbes.rda"))
```

It has been arbitrarily decided to keep only the
`r bigFormat(length(KeptProbes))` probes showing a MAD greater or equal
to `r sdThr`.

```{r cormat, cache=FALSE,echo=FALSE,include=FALSE}
corDir <- here("Data","06_Modules")
dir.create(corDir,showWarnings = FALSE)
## Create Spearman correlation matrix for all genes dislaying variance (MAD > 0.25) 
corMeth <- "spearman"
sampGroup <- "FCD2b"
sampleInfo <- sampleInfo %>% filter(PA_Diagnosis == "FCD 2b")
d <- vg$E[KeptProbes,pull(sampleInfo,GS_RNASEQ_ID)]
dim(d)
corFile <- here("Data","06_Modules/FCD2b/Module-Data",
                paste0(corMeth,"-KeptProbes-",sampGroup,".rda"))
##
if(!file.exists(here("Data","06_Modules","FCD2b/Module-Data/Modules-FCD2b.rda"))){
  if(!file.exists(corFile)){
    message(paste("Applying ", corMeth, " on ", sampGroup, "..."))
    message(Sys.time())
    message(corMeth, " correlation in ", sampGroup)
    corMat <- cor(t(d), method=corMeth)
    save(corMat,file=corFile)
    gc()
    message("... Done")
    message(Sys.time())
  }else{
    load(corFile)
  }
}
```

## Scale-free fit index

<blockquote>
Constructing a weighted gene network entails the choice of the
soft thresholding power Œ≤ to which co-expression
similarity is raised to calculate adjacency
([Zhang and Horvath 2005](https://www.ncbi.nlm.nih.gov/pubmed/16646834)).
[Zhang and Horvath (2005)](https://www.ncbi.nlm.nih.gov/pubmed/16646834)
have proposed to choose the soft thresholding
power based on the criterion of approximate scale-free topology.
<footer><cite>
[Tutorial for the WGCNA package for R](https://labs.genetics.ucla.edu/horvath/htdocs/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Consensus-NetworkConstruction-man.pdf)
</cite></footer>
</blockquote>

The figure below shows the the scale-free fit index and the mean connectivity as a function of the soft-thresholding power.

```{r scalefree,include=FALSE,echo=FALSE}
## Scale-free fit index
defaultSoftPower <- 6
## Choose a set of soft-thresholding powers
powers <- 1:20
## Call the network topology analysis function
r2cut <- 0.85
sFile <- here("Data", "06_Modules/FCD2b/Module-Data", "ScaleFreeIndex_FCD2b.rda")
if(file.exists(sFile)){
  load(sFile)
}else{
  sft <- WGCNA::pickSoftThreshold(t(d),
                           powerVector = powers,
                           RsquaredCut = r2cut,
                           verbose = 0,
                           corOptions = list(method=corMeth)
                           )
  save(sft, file = sFile)
}
```

```{r scalefree_plot,include=TRUE,echo=FALSE, fig.height=5}
opar <- par(no.readonly=T)
par(mfrow = c(1,2));
cex1 = 0.9;
## Scale-free topology fit index as a function of the soft-thresholding power
plot(
  sft$fitIndices[,1],
  -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
  xlab="Soft Threshold (power)",
  ylab="Scale Free Topology Model Fit, signed R¬≤",
  type="n",
  main = "Scale independence"
)
text(
  sft$fitIndices[,1],
  -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
  labels=powers, cex=cex1, col="red"
)
abline(h=r2cut,col="red", lty=2)
abline(
  h=-sign(sft$fitIndices[,3])*sft$fitIndices[,2][which(sft$fitIndices[,1]==defaultSoftPower)],
  col="blue", lty=2
)
## Mean connectivity as a function of the soft-thresholding power
plot(
  sft$fitIndices[,1],
  sft$fitIndices[,5],
  xlab="Soft Threshold (power)",
  ylab="Mean Connectivity", type="n",
  main = paste("Mean connectivity")
)
text(
  sft$fitIndices[,1],
  sft$fitIndices[,5],
  labels=powers,
  cex=cex1,
  col="red"
)
par(opar)
```

## Unsupervised hierarchical clustering and defining the optimal number of clusters

```{r clust,include=FALSE,echo=FALSE}
clMeth <- "ward.D"
softPower <- defaultSoftPower
minClusSize <- 1
##
subcorDir <- here("Data", "06_Modules/FCD2b", "ClustModules")
dir.create(subcorDir,showWarnings = FALSE)
corFile <- here("Data", "06_Modules/FCD2b", "ClustModules", "Clustering_FCD2b.rda")
##
if(file.exists(corFile)){
  load(corFile)
}else{
  distMat <- 1-abs(corMat)^softPower
  distMat <- as.dist(distMat)
  tree  <- stats::hclust(d=distMat, method=clMeth)
  rm(distMat)
  gc()
}
```

Clustering using the `r clMeth` clustering method is performed on the correlation matrix.  

```{r treecut,echo=FALSE}
if(!file.exists(corFile)){
  cutOpt <- treeCutQual(
    tree, 
    corMat,
    k.min = 1, 
    k.max = 200 ,
    minsize = minClusSize ,
    d = d, 
    corMeth = corMeth #, mc.cores=3
  )
  kinfl <- CoReMo::getInflPoint(cutOpt[,c("k", "R2 weighted median")])
  rm(cutOpt)
  gc()
}
```

The optimal number of clusters was identified using a static cut comparing different levels of K clusters. The chosen number of clusters is selected when the increase of weighted average
of R<sup>2</sup> reaches a plateau ($d(dy/dx)/dx \approx 0$). No minimum cluster size for the downstream analyses has been set. 

```{r treecut_plot, include=TRUE,echo=FALSE, fig.height=6}
CoReMo::plotInfl(kinfl)
ksel <- attr(kinfl, "xlim")
```

```{r clustqual, echo=FALSE}
if(!file.exists(corFile)){
  clusters <- CoReMo::msCutree(tree, 
                               k = ksel, 
                               minsize = minClusSize, 
                               d = d, 
                               corMeth = corMeth)
  qc <- CoReMo::clQual(clusters, 
                       corMat = corMat)
  junkModule <- rownames(qc)[which(qc[,"r2med"] < 0.05)]
  inJunk <- names(clusters)[which(clusters == junkModule)]
  notInJunk <- setdiff(names(clusters), inJunk)
  save(
    tree, kinfl, clusters, qc, junkModule, inJunk, notInJunk,
    file = corFile
  )
}
```

Genes have finally been divided into `r nrow(qc)` modules (including one junk module).

## Module robustness

The leave-one-out bootstrapping procedure is used to assess the impact of samples on the stability and robustness of gene coregulation modules. For each permutation, the correlation matrix is calculated and the modules are constructed and their membership recorded. To apply this procedure, the number of clusters has already been defined beforehand using the full dataset and standard CoReMo procedure. This procedure only aims to identify more robust module memberships by LOO bootstrapping. Finally, a similarity matrix is build based on cluster membership across the different permutations to identify junk modules based on an arbitrary threshold. After identification of junk module members, these are removed from the analyses and the remaining genes are clustered by using the similarity matrix as input. These are the robust modules derived from LOO bootstrapping procedure. 

```{r module_settings}
wgcna.clMeth      <- "ward.D"
wgcna.corMeth    <- "spearman"
wgcna.softPower   <- 6
wgcna.minClusSize <- 1
wgcna.k        <- 15
```

```{r, eval = FALSE}
source(here("Analysis/E01-Module-Robustness-Bootstrapping.R"))
```

```{r ls_permutate_modules}
load(here("Data/06_Modules/FCD2b/Module-Data/LOO_FCD2b_Cluster.rda"))
load(here("Data/06_Modules/FCD2b/Module-Data/Bootstrapping_Similarity_FCD2b.rda"))
```

After application of the leave-one-one procedure, `r length(unique(junk.genes))` genes are categorized as junk genes in at least one bootstrap. `r table(junk.genes) %>% {.[. == 65]} %>% length` genes are always assigned to the junk genes. If gene is assigned to the junk module more than 50% of the permutations, this gene will be considered as junk, leaving `r length(junk.genes.out)` genes within the junk module that are and are removed from the analysis. Finally, the modules are constructed by clustering the remaining gene using the similarity matrix constructed during bootstrapping. This matrix captures the number of times gene are co-clustered during the leave-one-out procedure resulting in more robust modules. This leaves `r nrow(LOO.clusters) - length(junk.genes.out)` assigned to 15 coexpression modules. 

```{r, include = FALSE}
junk.genes.thres <- (length(unique(mod.decision$Bootstrap)) - 1)/2
hist(as.vector(table(junk.genes)))
abline(v = junk.genes.thres)
```


```{r ls_consensuscluster}
# Consensus Cluster
dist.matrix <- as.dist(1 - (similarity.mat/(ncol(LOO.clusters)-1)))
# Simple Ordering
clus.memb   <- dist.matrix %>%
  stats::hclust(., method = "ward.D") %>%
  cutree(., k=(wgcna.k-1)) %>% sort
hm.order    <- names(clus.memb)
sim.mat.out <- similarity.mat %>%
               .[match(hm.order, rownames(.)),] %>%
               .[,match(hm.order, colnames(.))]

## Compare to original clusters
BS_clusters <- LOO.clusters %>%
  dplyr::select(ensgene, BS_0) %>%
  left_join(stack(clus.memb) %>%
              mutate_if(is.factor, as.character) %>%
              rename(BSF = values,
                     ensgene = ind),
            by = "ensgene")
```


```{r}
# Internal Module Correlation vs Average Similarity
if(file.exists(here("Data/06_Modules/FCD2b/Module-Data/FCD2b_CorrMembership.rda"))){
  load(here("Data/06_Modules/FCD2b/Module-Data/FCD2b_CorrMembership.rda"))
}else{
  data.modcor <- data.frame()
  for(j in 1:max(clus.memb)) {
    subset.genes  <- clus.memb %>% .[. == j] %>% names
    cormat.subset <- corMat %>%
                     .[subset.genes, subset.genes] %>%
                     .[upper.tri(.)] %>% abs %>%
                     {. ^ 2} %>% mean
  
    cormat.sim    <- similarity.mat %>%
                     .[subset.genes,subset.genes] %>%
                     .[upper.tri(.)] %>% median
    module.size   <- length(subset.genes)
    data.modcor   <- rbind(data.modcor, c(j, cormat.subset, module.size, cormat.sim))
  }
  data.modcor <- data.modcor %>%
                 as.data.frame %>%
                 `colnames<-`(c("Module", "Median R2", "Module Size", "Median Similarity"))
  data.clusters <- clus.memb
  data.cormat   <- corMat[names(data.clusters),names(data.clusters)]
  save(data.clusters, data.cormat, data.modcor, 
       file = here("Data/06_Modules/FCD2b/Module-Data/FCD2b_CorrMembership.rda"))
}
```

```{r, include = FALSE}
datatable(data.modcor,
          rownames = FALSE) %>%
  formatSignif(2, digits = 2)
```

The plot belows shows the module's median R¬≤ and its median similarity within each module, namely the median of the number of times genes within the modules are co-clustered during the leave-one-out bootstrapping procedure. The size represents the number of genes within the module.

```{r, include = TRUE, fig.height=5}
modcor.gg   <- data.modcor %>%
               ggplot(., aes(`Median Similarity`, `Median R2`, label = `Module`)) +
               geom_vline(xintercept = 5,   linetype = "dashed", alpha = 0.5) +
               geom_hline(yintercept = 0.2, linetype = "dashed", alpha = 0.5) +
               geom_point(aes(size = `Module Size`)) +
               geom_label_repel() +
               theme_bw() +
               labs(title = "Mean Similarity Against Module Internal Median R2")
ggplotly(modcor.gg)
```

```{r size_plot,include = FALSE}
plot(
 data.modcor$`Module Size`, data.modcor$`Median R2`,
  # log = "x",
  xlab = "size", ylab = "R¬≤",
  main = paste("Module quality in", sampGroup),
  type = "n"
)
text(
  data.modcor$`Module Size`, data.modcor$`Median R2`,
  rownames(data.modcor),
  cex=0.5
)
```

Data of the modules is available in the **Data/06_Modules/FCD2b** folder.

<!-- Below the table shows the number of genes included in each of the gene modules of co-expression. -->

```{r size_tb,include=FALSE,echo=FALSE, eval = FALSE}
toShow <- as.data.frame(table(data.clusters))
datatable(
 toShow,
 rownames=FALSE,
 colnames=c("Module","Number of genes"),
 elementId=paste0("ModuleNamesShow-", round((10^6)*runif(1)))
)
```

## Module overview and association to phenotype

After construction of the modules, potential sub-modules are identified when positively correlated and anti-correlated genes are present in the module. The sub-modules are identified by the suffix "o" and "u" based on the median logFC compared to the control samples. 

```{r}
getSubModules <- function(corMat, logFC){
  stopifnot(!is.null(names(logFC)))
  modTree <- hclust(as.dist(1 - corMat))
  subMod <- cutree(modTree, k = 2)
  imCor <- median(corMat[names(subMod)[which(subMod == 1)], 
                         names(subMod)[which(subMod == 2)]], na.rm = TRUE)
  if(imCor > 0){
    subMod <- list(`1` = rownames(corMat), `2` = c())
  }else{
    subMod <- split(names(subMod), subMod)
  }
  subModDeg <- lapply(subMod, function(x) {
    logFC[intersect(names(logFC), x)]
  })
  smdAvg <- unlist(lapply(subModDeg, mean, na.rm = TRUE))
  smdAvg <- ifelse(is.na(smdAvg), 0, smdAvg)
  if(!is.na(smdAvg[2])){
    if(smdAvg[1] <= smdAvg[2]){
      smdNames <- c("u", "o")
    }else{
      smdNames <- c("o", "u")
    }
  }else{
    if (smdAvg[1] < 0) {
      smdNames <- c("u", "o")
    }else{
      smdNames <- c("o", "u")
    }
  }
  names(subMod) <- names(subModDeg) <- smdNames
  return(subMod[c("o", "u")])
}
```

```{r mod_anno, cache=FALSE,eval = TRUE, echo=FALSE}
corFile <-  here("Data","06_Modules/FCD2b/Module-Data","Modules-FCD2b.rda")
if(file.exists(corFile)){
  load(corFile)
}else{
  modules <- list()
  modules.Ensembl <- list()
  modules.entrez <- list()
  
  ## Gene
  for(mid in unique(data.clusters)){
    m <- names(data.clusters[which(data.clusters == mid)])
    mid <- paste(sampGroup, mid, sep = ".")
    resFile2 <- file.path(subcorDir, paste0(mid, "-bcs.rda"))
    if(file.exists(resFile2)){
      load(resFile2)
    }else{
      mCorMat <- data.cormat[m, m]
      attr(mCorMat, "geneMed") <- apply(mCorMat^2, 2, median) # squared values
      save(mCorMat, file=resFile2)
    }
    lfc <- deg[m, "logFC"]
    names(lfc) <- m
    modules.Ensembl[[mid]] <- getSubModules(mCorMat, lfc)
    modules[[mid]] <- mCorMat
  }
  ## Convert to Entrez gene IDs
  modules.entrez <- lapply(
    modules.Ensembl,
    convBeIdLists,
    from = "Gene", from.source = "Ens_gene", from.org = "human",
    to = "Gene", to.source = "EntrezGene", to.org = "human",
    restricted=TRUE
  )
  moduleList <- BED::BEIDList(rlist::list.flatten(modules.Ensembl))
  save(modules, modules.Ensembl, modules.entrez, moduleList, file = corFile)
}
rm(corMat, mgtex, mCorMat, clust.memb, cormat.sim, cormat.subset)
gc()
```

```{r, include = FALSE, eval = FALSE}
toShow <- stack(rlist::list.flatten(modules.Ensembl)) %>%
  as_tibble() %>%
  mutate_if(is.factor, as.character) %>%
  mutate(`Sub-module` = gsub(".*[.]", "", ind),
         Module =  substr(ind, start = 1, stop = nchar(ind) - 2))
geneDescr <- getBeIdDescription(ids = toShow$values, be = "Gene", source = "Ens_gene", organism = "human")

## drug targets / epilepsy variants
load(here("Data/epilepsy_variant_list.rda"))
load(here("Data/epilepsy_drug_targets.rda"))
  
toShow <- toShow %>%
  left_join(geneDescr,
            by = c("values" = "id")) %>%
  mutate(Gene = paste0(sprintf('<a href="%s" target="_blank">%s</a>',
                                    getBeIdURL(values, 
                                               databases = "Ens_gene"),
                                    symbol)),
         Module = as.factor(Module),
         `Sub-module` = as.factor(`Sub-module`),
         `Drug target` = case_when(values %in% geneList_drugtargets$epilepsy ~ TRUE,
                                   TRUE ~ FALSE),
         `Epilepsy variant` = case_when(values %in% geneList$epilepsy ~ TRUE,
                                   TRUE ~ FALSE)) 
datatable(toShow %>%
  select(Module, `Sub-module`, Gene, `Gene name` = name, 
         ensembl_id = values), #, `Drug target`, `Epilepsy variant`),  
            filter = "top",
            rownames = FALSE,
            escape = FALSE,
            extensions = 'Buttons',
            # options = list(dom = 'Blfrtip',
            #                buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
            #                lengthMenu = list(c(10,25,50,-1),
            #                                  c(10,25,50,"All"))))
            options = list(
              dom = "Blfrtip",
              buttons = c('csv'),
              columnDefs = list(list(visible=FALSE, targets=4)),
              pageLength = 6,
              order = list(list(0, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '150px', targets = c(0, 1, 2)))))
```  

The association of the module with any of the recorded phenotypes is tested using linear regression for each module's eigenGene and the different phenotypes. As duration and age are not independent of each other, the association for duration is corrected for age.  

The table below shows the overview of the modules, the number of genes, average R¬≤, and FDR of the association with different phenotypes. 

```{r batchAss}
## Eigen genes
mvec <- stack(lapply(modules.Ensembl, unlist))
mvecVal <- as.character(mvec$ind)
names(mvecVal) <- mvec$values
mvec <- mvecVal
rm(mvecVal)
length(mvec)
##
eigenGenes <- getEigenValues(mvec, d)
egg <- t(eigenGenes)
tb <- sampleInfo[match(rownames(egg), sampleInfo$GS_RNASEQ_ID),] %>%
  as_tibble()
egg <- cbind(tb, egg) %>%
 mutate(
   Gender = as.factor(Gender)
 )
## Checking pup/batch/gender effects on module construction
modulesTable <- list()

size <- sapply(modules.Ensembl, function(x){length(unlist(x))} )
r2 <- sapply(modules, function(x){median(as.dist(x^2))})
o.size <- sapply(modules.Ensembl, function(x){length(x$o)})
u.size <- sapply(modules.Ensembl, function(x){length(x$u)})

##
seizfreqAss <- p.adjust(apply(
   egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=egg$log10_seizure_freq
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
##
genderAss <- p.adjust(apply(
     egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc, 
         groups=as.factor(egg$Gender)
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
##
ageAss <- p.adjust(apply(
     egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=egg$Age_At_Time_of_Operation
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
##
durAss <- p.adjust(apply(
     egg[,grep("HS[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=egg[, c("Duration_years", "Age_At_Time_of_Operation")]
      )
       drop1(lm(data=toTest,
                 formula=val~groups.Duration_years+groups.Age_At_Time_of_Operation),
             test="F")[2,"Pr(>F)"]
   }
), method="BH")
##
SGIDAss <- p.adjust(apply(
    egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=as.factor(egg$SGID)
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
##
libAss <- p.adjust(apply(
    egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=as.factor(egg$Library_Prep_batch)
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
##
tissueAss <- p.adjust(apply(
    egg[,grep("FCD2b[.]",colnames(egg))], 2,
   function(pc){
      toTest <- data.frame(
         val=pc,
         groups=as.factor(egg$Area_of_Resection)
      )
      summary(aov(formula=val~groups, data=toTest))[[1]]$`Pr(>F)`[1]
   }
), method="BH")
modulesTable <- tibble(Module = names(modules.Ensembl), 
                       `Module size` = size,
                       R2 = r2,
                       `O Size` = o.size,
                       `U Size` = u.size,
                       `Seizure frequency` = seizfreqAss[names(modules.Ensembl)],
                       Age = ageAss[names(modules.Ensembl)],
                       Gender = genderAss[names(modules.Ensembl)],
                       `Duration (years)` = durAss[names(modules.Ensembl)],
                       `Sequencing group` = SGIDAss[names(modules.Ensembl)],
                       `Library batch` = libAss[names(modules.Ensembl)],
                       Tissue = tissueAss)
save(modulesTable, file = here("Data", "06_Modules/FCD2b/Module-Data/PhenotypeAssociation.rda"))
```

```{r, include = TRUE}
shown <- datatable(modulesTable) %>%
  formatSignif(c(3,6:11), digits = 2) %>%
  formatStyle(
     c(6:11),
     backgroundColor = styleInterval(c(0.05), c('#afe575', 'transparent'))) %>%
  formatStyle(
     "O Size",
     background = styleColorBar(modulesTable$"O Size", "#F08080"),
     backgroundSize = '100% 90%',
     backgroundRepeat = 'no-repeat',
     backgroundPosition = 'center') %>% 
  formatStyle(
     "U Size",
     background = styleColorBar(modulesTable$"U Size", "#F08080"),
     backgroundSize = '100% 90%',
     backgroundRepeat = 'no-repeat',
     backgroundPosition = 'center')
absMax <- max(abs(range(modulesTable$R2, na.rm=TRUE)))
breaks <- seq(-absMax, absMax, length.out=20)
cols <- colorRampPalette(c("blue", "white", "red"))(21)
shown <- formatStyle(
  shown, "R2",
  backgroundColor = styleInterval(breaks, cols)
)
shown
```


# Functional annotation {.tabset}

In this section, each module is functionally annotated by calculating the overlap of the genes inside with different biological databases. To establish whether the overlap between a module‚Äôs genes and genes in a biological pathway is significant a hypergeometric test is used.

```{r}
toTest <- rlist::list.flatten(modules.Ensembl)
eg <- rownames(d)
bescope = list(be = "Gene", source = "Ens_gene", organism = "human")
```

## MetaBase pathway maps

```{r}
if(file.exists(faFile)){
  load(faFile)
}else{
  nbeidsLim <- c(10, 500)
  fl <- do.call(focusOnScope, c(
     list(
        x=getBekBeids(
           externalKnowledge="MetaBase_pathway",
           nbeids=nbeidsLim
        ),
        force=TRUE
     ),
     bescope
  ))
  tmp <- unlist(lapply(fl, length))
  fl <- fl[which(tmp>=min(nbeidsLim) & tmp <= max(nbeidsLim))]
  names(fl) <- metadata(fl)$externalID
  res <- TBTools::qrlEnrich(
     query=toTest, reference=fl,
     omega=eg,
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resMB <- res %>% 
    mutate(type = "MetaBase_pathway") %>%
    inner_join(metadata(fl) %>% select("externalID", name), 
               by = c("ruuid" = "externalID")) %>%
    mutate(Pathway = paste0(sprintf('<a href="https://portal.genego.com/cgi/imagemap.cgi?id=%s" target="_blank">%s</a>',
                                    ruuid,
                                    name)))
}
```

```{r, include = TRUE}
datatable(resMB %>%
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = Pathway,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank) %>%
            mutate(Module = as.factor(Module)), 
          filter = "top",
          escape = FALSE,
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),
          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```

## Reactome pathways

```{r}
if(!file.exists(faFile)){
  nbeidsLim <- c(10, 500)
  fl <- do.call(focusOnScope, c(
     list(
        x=getBekBeids(
           externalKnowledge="Reactome_pathways_human",
           nbeids=nbeidsLim
        ),
        force=TRUE
     ),
     bescope
  ))
  tmp <- unlist(lapply(fl, length))
  fl <- fl[which(tmp>=min(nbeidsLim) & tmp <= max(nbeidsLim))]
  names(fl) <- metadata(fl)$externalID

  res <- qrlEnrich(
     query=toTest, reference=fl,
     omega=eg,
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resRA <- res %>% 
    mutate(type = "Reactome_pathways_human") %>%
    inner_join(metadata(fl) %>% select(externalID, name), 
               by = c("ruuid" = "externalID")) %>%
    mutate(Pathway = paste0(sprintf('<a href="http://www.reactome.org/PathwayBrowser/#/%s" target="_blank">%s</a>',
                                    ruuid,
                                    name)))
}
```


```{r, include = TRUE}
datatable(resRA %>%
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = Pathway,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank)%>%
            mutate(Module = as.factor(Module)),
          filter = "top",
          escape = FALSE,
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),
          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```

## Gene Ontology: biological process

```{r}
if(!file.exists(faFile)){

  nbeidsLim <- c(10, 500)
  fl <- do.call(focusOnScope, c(
     list(
        x=getBekBeids(
           externalKnowledge="GO_biological_process_human",
           nbeids=nbeidsLim
        ),
        force=TRUE
     ),
     bescope
  ))
  tmp <- unlist(lapply(fl, length))
  fl <- fl[which(tmp>=min(nbeidsLim) & tmp <= max(nbeidsLim))]
  names(fl) <- metadata(fl)$externalID

  res <- qrlEnrich(
     query=toTest, reference=fl,
     omega=eg,
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resGOBP <- res %>% 
    mutate(type = "GO_biological_process_human") %>%
    inner_join(metadata(fl) %>% select(externalID, name), 
               by = c("ruuid" = "externalID")) %>%
    mutate(Pathway = paste0(sprintf('<a href="http://amigo.geneontology.org/amigo/term/GO:%s" target="_blank">%s</a>',
                                    ruuid,
                                    name)))
}
```


```{r, include = TRUE}
datatable(resGOBP %>%
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = Pathway,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank) %>%
            mutate(Module = as.factor(Module)),
                   # Concept = as.factor(Concept)),
          filter = "top",
          escape = FALSE,
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),
          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```

## Gene Ontology: molecular function

```{r}
if(!file.exists(faFile)){

  nbeidsLim <- c(10, 500)
  fl <- do.call(focusOnScope, c(
     list(
        x=getBekBeids(
           externalKnowledge="GO_molecular_function_human",
           nbeids=nbeidsLim
        ),
        force=TRUE
     ),
     bescope
  ))
  tmp <- unlist(lapply(fl, length))
  fl <- fl[which(tmp>=min(nbeidsLim) & tmp <= max(nbeidsLim))]
  names(fl) <- metadata(fl)$externalID

  res <- qrlEnrich(
     query=toTest, reference=fl,
     omega=eg,
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resGOMF <- res %>% 
    mutate(type = "GO_molecular_function_human") %>%
    inner_join(metadata(fl) %>% select(externalID, name), 
               by = c("ruuid" = "externalID")) %>%
    mutate(Pathway = paste0(sprintf('<a href="http://amigo.geneontology.org/amigo/term/GO:%s" target="_blank">%s</a>',
                                    ruuid,
                                    name)))
}
```


```{r, include = TRUE}
datatable(resGOMF %>%
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = Pathway,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank) %>%
            mutate(Module = as.factor(Module)),
          filter = "top",
          escape = FALSE,
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```

## Gene Ontology: cellular component

```{r}
if(!file.exists(faFile)){

  nbeidsLim <- c(10, 500)
  fl <- do.call(focusOnScope, c(
     list(
        x=getBekBeids(
           externalKnowledge="GO_cellular_component_human",
           nbeids=nbeidsLim
        ),
        force=TRUE
     ),
     bescope
  ))
  tmp <- unlist(lapply(fl, length))
  fl <- fl[which(tmp>=min(nbeidsLim) & tmp <= max(nbeidsLim))]
  names(fl) <- metadata(fl)$externalID

  res <- qrlEnrich(
     query=toTest, reference=fl,
     omega=eg,
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resGOCC <- res %>% 
    mutate(type = "GO_cellular_component_human") %>%
    inner_join(metadata(fl) %>% select(externalID, name), 
               by = c("ruuid" = "externalID")) %>%
    mutate(Pathway = paste0(sprintf('<a href="http://amigo.geneontology.org/amigo/term/GO:%s" target="_blank">%s</a>',
                                    ruuid,
                                    name)))
}
```


```{r, include = TRUE}
datatable(resGOCC %>%
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = Pathway,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank) %>%
            mutate(Module = as.factor(Module)),
          filter = "top",
          escape = FALSE,
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```


## PangloaDB cell type biomarkers

```{r}
if(!file.exists(faFile)){
  library(TKCat)
  tkcon <- chTKCat(password = "")
  pangloadb <- get_MDB(tkcon,"PanglaoDB")
  fl <- inner_join(pangloadb$PanglaoDB_Markers,
                   pangloadb$PanglaoDB_Genes %>% select(symbol, ensembl),
                   by = c("symbol")) %>% 
    inner_join(pangloadb$PanglaoDB_CellTypes %>% select(`cell type`, organ),
               by = c("cell type")) %>% 
    filter(grepl("ENSG", ensembl))
  sfl <- split(fl$ensembl, fl$`cell type`)
  
  res <- qrlEnrich(
     query=toTest, reference=sfl,
     omega=unlist(eg),
     mc.cores=30
  )
  colnames(res) <- c(
     "uuid", "query", "ruuid", "reference",
     "intersection", "p-value", "FDR"
  )
  res <- do.call(rbind, by(
     res,
     res$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(res) <- NULL
  resPAN <- res %>% 
    mutate(type = "PangloaDB cell type biomarkers") %>% 
    mutate(Organ = fl$organ[match(ruuid, fl$`cell type`)])
  save(resMB, resRA, resGOBP, resGOMF, resGOCC, resMSig, resHB, resPAN, resCTEN, resMGD,
     file = faFile)
}
```

```{r, include = TRUE}
datatable(resPAN %>%        
            filter(FDR <= 0.05) %>%
            select(Module = uuid,
                   `Module size` = query,
                   Concept = ruuid,
                   Organ,
                   `Concept size` = reference,
                   Intersect = intersection,
                   FDR,
                   `Relative rank` = relRank) %>%
            mutate(Module = as.factor(Module)),
          filter = "top",
          options = list(
              order = list(5, "asc"),
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '100px', targets = c(0, 2)))),
          rownames = FALSE) %>%
  formatSignif(6:7, digits = 2)
```


# Assessment of conservation

In this section, the conservation of the properties of the identified modules is assess in other normal and disease conditions. The conservation of a module's median correlation (R¬≤) in another conditions is assessed using 1000 permutations over module membership. In addition, a module's median R¬≤ assess the level of coregulation. Several technical artifacts may influence the significance of conservation, such as differences in sequencing technologies, study, and conversion of identifiers between organisms. Due to these technical artifacts, we can only interpret modules that are significantly conserved across conditions.

```{r, eval = FALSE}
# source(here("Analysis/S00-Conservation-Modules.R"))
```

```{r, include = TRUE, eval = TRUE}
if(file.exists( here("Data/06_Modules/FCD2b/Conservation/FCD2b_ConservationResults.rda"))){
  load( here("Data/06_Modules/FCD2b/Conservation/FCD2b_ConservationResults.rda"))
}else{
  ## Reference = FCD2b modules ----
  load(here("Data/06_Modules/FCD2b/Conservation/FCD2b_Conservation.rda"))
  conservation <- do.call(rbind,
                          lapply(names(toRet),
                                 function(x){
                                   toRet <- toRet[[x]]$conservation %>%
                                     # filter(FDR <= 0.05) %>%
                                     mutate(Project = sub("_.*", "", x),
                                            Condition = sub(paste0(unique(Project),"_"), "",
                                                            x)) %>% 
                                     select(Project,
                                            Condition,
                                            Module = l, 
                                            R2 = value,
                                            p.value, 
                                            FDR) %>%
                                     distinct()
                                   if(!all(names(moduleList) %in% toRet$Module)){
                                     toAdd <- tibble(Project = gsub("_.*", "", x),
                                                     Condition = gsub(".*_", "", x),
                                                     Module = names(moduleList),
                                                     R2 = NA,
                                                     p.value = NA, 
                                                     FDR = NA) %>%
                                       filter(!Module %in% toRet$Module)
                                     toRet <- bind_rows(toRet,
                                                        toAdd)
                                   }
                                   return(toRet)
                                 })) 
  crosstabulation <- do.call(rbind,
                          lapply(names(toRet),
                                 function(x){
                                   toRet <- toRet[[x]]$crossTab %>%
                                     # filter(FDR <= 0.05) %>%
                                     mutate(Project = sub("_.*", "", x),
                                            Condition = sub(paste0(unique(Project),"_"), "",
                                                            x)) %>% 
                                     select(Project,
                                            Condition,
                                            Module = q,
                                            `Module size` = qsize,
                                            `External module` = r,
                                            `External size` = rsize,
                                            intersect = i,
                                            "P-Value",
                                            FDR) 
                                   return(toRet)
                                 })) 
  
  ## AMC controls
  load(here("Data/06_Modules/FCD2b/Conservation/FCD2b_AMC_Control_Conservation.rda"))
  toAdd <- do.call(rbind,
                          lapply(names(toRet),
                                 function(x){
                                    toRet <- toRet[[x]]$conservation %>%
                                     # filter(FDR <= 0.05) %>%
                                     mutate(Project = gsub("_.*", "", x),
                                            Condition = gsub("AMC_", "", x)) %>% 
                                     select(Project,
                                            Condition,
                                            Module = l, 
                                            R2 = value,
                                            p.value, 
                                            FDR) %>%
                                     distinct()
                                   if(!all(names(moduleList) %in% toRet$Module)){
                                     toAdd <- tibble(Project = gsub("_.*", "", x),
                                                     Condition = gsub(".*_", "", x),
                                                     Module = names(moduleList),
                                                     R2 = NA,
                                                     p.value = NA, 
                                                     FDR = NA) %>%
                                       filter(!Module %in% toRet$Module)
                                     toRet <- bind_rows(toRet,
                                                        toAdd)
                                   }
                                   return(toRet)
                                 }))
  conservation <- bind_rows(conservation, toAdd)
  
  save(conservation, crosstabulation, 
       file = here("Data/06_Modules/FCD2b/Conservation/FCD2b_ConservationResults.rda"))
}
```

```{r, include = FALSE, eval = TRUE, plotly = TRUE, fig.width = 10, fig.height = 10}
toShow <- conservation %>%
  mutate(Analysis = paste(Project, Condition, sep = "_")) %>%
  select(Analysis, Module, FDR) %>%
toShow <- reshape2::dcast(toShow, Analysis~Module)
rownames(toShow) <- toShow[,1]
toShow <- toShow[,-1]
toShow <-  data.matrix(toShow)
toShow[is.na(toShow)] <- 1
toPlot <- -log10(toShow)
heatmaply::heatmaply(data.matrix(toPlot), 
                     show_dend=c(FALSE, TRUE), 
                     fontsize_row = 6, 
                     fontsize_column = 6)  %>%
  layout(width = 1200)
```



## Corresponding modules in other cohorts

Using a hypergeometric test, the overlap of gene content between different modules across studies can be assessed. The table below shows the modules significantly overlapping the FCD 2b modules. 

```{r, include = TRUE, eval = TRUE}
datatable(crosstabulation  %>%
           mutate(Project = as.factor(Project),
                  Condition = as.factor(Condition),
                  Module = as.factor(Module))  %>%
           filter(FDR <= 0.05),
          rownames = FALSE,
          filter = "top",
          options = list(
              dom = "tp",
              pageLength = 6,
              order = list(list(3, "asc")),
              autoWidth = TRUE,
              columnDefs = list(list(width = '150px', targets = c(0, 1, 2)))),
          class = "display",
          escape = FALSE) %>%
    formatSignif(c("FDR"), digits = 2)
```

# Differential co-expression

To establish which modules are differentially co-expressed between `r nrow(all_samples %>% filter(PA_Diagnosis == "FCD 2b"))` FCD 2b  and `r nrow(all_samples %>% filter(PA_Diagnosis == "Control"))` control samples we compare the difference in median R¬≤ with the null distribution created by permuting over samples (number of permutations: 10,000).


```{r,echo=FALSE,include=FALSE}
if(file.exists(here("Data/06_Modules/FCD2b/Module-Data/DifferentialCoexpression_FCD2b.rda"))){
  load(here("Data/06_Modules/FCD2b/Module-Data/DifferentialCoexpression_FCD2b.rda"))
}else{
  corMeth <- "spearman"
  indTable <- all_samples %>% select(GS_RNASEQ_ID, PA_Diagnosis)
  genesKept <- rownames(data.cormat)
  pm <- 10000
  
  corFile <- here("Data/06_Modules/FCD2b/Conservation/DifferentialCoexpression_FCD2b.rda")
  if(file.exists(corFile)){
    load(corFile)
  }else{
    source("S07-FCD2b-Differential-Coexpression.R")
  }
  
  corMat0 <- cor(t(vg$E[genesKept, 
                         all_samples$GS_RNASEQ_ID[all_samples$PA_Diagnosis == "Control"]]),
                 method=corMeth)
  dim(corMat0) 
  corMat <- data.cormat
  r20 <- sapply(moduleList, function(x){
    median(as.dist(corMat0[x, x]^2))
    })
  r2 <- sapply(moduleList, function(x){
    median(as.dist(corMat[x,x]^2))})
  DC <-   r2 - r20
  
  ##
  ## When R¬≤ < 0 -> test whether sign. more values show lower R¬≤
  t <- DC[DC < 0]
  pval <- apply(cbind(DC[names(t)],rDC[names(t),]),1,
                 function(x){
                   sum(x[-1] <= x[1])/length(x)
                 })
  ## When R¬≤ > 0 -> test whether sign. more values show higher R¬≤
  t <- DC[DC > 0]
  pval <- c(pval, apply(cbind(DC[names(t)],rDC[names(t),]),1,
               function(x){
                 sum(x[-1] >= x[1])/length(x)
               }))
  
  DC.df <- data.frame("Module" = names(DC),
                      "R2 control" = r20[names(DC)],
                      "R2 FCD 2b" = r2[names(DC)],
                      "Difference Median" = round(DC,digits = 3),
                      "P-value" = pval[names(DC)],
                      stringsAsFactors = FALSE)
  save(DC.df, file = here("Data/06_Modules/FCD2b/Module-Data/DifferentialCoexpression_FCD2b.rda"))
}
```

<br>
The table below shows the median R¬≤ values for FCD 2b and control samples, difference in median R¬≤ between the two conditions, and the empirical p-value. 
<br>

```{r, include = TRUE}
datatable(   DC.df,
   rownames=FALSE,
   colnames = c("Module", "R¬≤ control", "R¬≤ FCD 2b", "Difference", "P-value"),
   filter = "top",
   options = list(
    dom = "tp",
    pageLength = 6,
    order = list(list(3, "asc")),
    autoWidth = TRUE,
    columnDefs = list(list(width = '150px', targets = c(0)))),
   elementId=paste0("ModuleNamesShow-", round((10^6)*runif(1)))) %>%
  formatSignif(2:4, 2) %>%
  formatSignif(5, 3)
```

# Causal reasoning {.tabset}

Signal transduction pathways from cell membrane proteins (CMP) to transcription factors (TF) are identified using the MetaBase network and pathway maps.

```{r}
## Establish connection to MetaBase database
# source("~/Shared/Data-Science/CBDD/metabaseConnection-bel028272.R")

if(file.exists(here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))){
  load(here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))
}else{
  expressedGenes <- rownames(vg$E)
  availableObjects <- listBEIDs(
     bes="Object", sources="MetaBase_object"
  )
  availableObjects <- convDfBeIds(
     availableObjects,
     idCol="value",
     from="Object", from.source="MetaBase_object", from.org="human",
     to="Gene", to.source="Ens_gene",
     restricted=TRUE, prefFilter=TRUE
  )
  availableObjects$available.g <- is.na(availableObjects$conv.to) |
     availableObjects$conv.to %in% expressedGenes
  
  gByO <- availableObjects[which(!is.na(availableObjects$conv.to)),]
  gByOl <- split(gByO$conv.to, gByO$conv.from)
  detected <- unique(gByO$conv.to[which(gByO$available.g)])
  ao <- absentObjects(gByOl, detected = detected)
  availableObjects$available.o <- ifelse(
     availableObjects$conv.from %in% ao,
     FALSE,
     TRUE
  )
  ## 
  ## miRNA
  load(here("Data/04_QC/Preprocessing_miRNA.rda"))
  expressedmiRNA <- mirbase_names %>%
    filter(ID %in% rownames(bc_mirna))
  availableObjects_mirna <- listBEIDs(bes="Object", sources="MetaBase_object") %>%
    filter(value %in% expressedmiRNA$object_id)
}
```

## Transcription factors

```{r}
if(!file.exists(here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))){
  ## + Available transcription factors ----
  trTargetsDf <- listBEInteractions(
     externalKnowledge="MetaBase_regulation",
     fromUuids = unique(
        availableObjects$uuid[which(availableObjects$available.o)]
     ),
     types=mb.transcription.regulations,
     organisms="Homo sapiens"
  )
  miRNATargetsDf <- listBEInteractions(
    externalKnowledge="MetaBase_regulation",
    types="miRNA binding",
    fromUuids = unique(availableObjects_mirna$uuid),
    organisms="Homo sapiens"
  )
  trTargetsDf <- unique(rbind(trTargetsDf, miRNATargetsDf))
  tr <- listBEIDs(uuids=unique(trTargetsDf$from))
  tr <- cbind(tr, getBeIdDescription(
     tr$value,
     be="Object", source="MetaBase_object", organism="human"
  ))
  
  ## + Targets of TF ---
  trTargetsDf <- merge(
     trTargetsDf,
     listBEIDs(uuids=unique(trTargetsDf$to)),
     by.x="to", by.y="uuid"
  )
  toAdd <- trTargetsDf[
     which(trTargetsDf$impact %in% c("Activation", "Inhibition")),
  ]
  toAdd$impact <- "Unspecified"
  trTargetsDfd <- rbind(trTargetsDf, toAdd)
  trTargets <- lapply(
     split(trTargetsDfd, trTargetsDfd$impact),
     function(x){
        toRet <- lapply(
           split(x, x$from),
           function(y){
              y$value
           }
        )
        scope <- as.list(unique(x[,c("be", "source", "organism.x")]))
        names(scope) <- c("be", "source", "organism")
        md <- tr[match(names(toRet), tr$uuid),]
        rownames(md) <- md$uuid
        return(BEIDList(
           l=toRet,
           metadata=md,
           scope=scope
        ))
        return(toRet)
     }
  )
  trTargets <- lapply(
     trTargets,
     focusOnScope,
     force=TRUE,
     be="Gene", source="Ens_gene", organism="human"
  )
  ## + Causal reasoning by enrichment analysis ----
  toTest <- rlist::list.flatten(modules.Ensembl)
  res <- lapply(
     trTargets,
     function(x){
       qrlEnrich(
         reference=x,
         query=toTest,
         omega=expressedGenes,
         mc.cores=30
       )
     }
  )
   cr_tf_res <- res
  ## Add grouping of regulators within each module/impact (regulators are grouped together when they share at least 50% of their targets)
  fres <- lapply(res,
                 function(t){
                   t %>%
                     filter(FDR <= 0.05)
                 })
  fres <- do.call(rbind,
                     lapply(names(toTest),
                            function(m){
                              do.call(rbind,
                                      lapply(names(fres),
                                              function(e){
                                               r <- fres[[e]] %>%
                                                 filter(q == m) %>%
                                                 mutate(value = listBEIDs(uuids = r)$value) %>% 
                                                 arrange(FDR)
                                               if(!is.null(r) & nrow(r) > 0){
                                                 if(nrow(r) == 1){
                                                   r$group <- 1
                                                   r$impact <- e
                                                 }else{
                                                   reg <- apply(r, 1,
                                                                function(x){intersect(toTest[[m]],
                                                                                      trTargets[[e]][[x[3]]])
                                                   })
                                                   names(reg) <- pull(r, `value`)
                                                   groups <- lgrouping(reg, distMeth = "jaccard",
                                                                       hcMeth = "average")
                                                   r$group <- groups[as.character(r$value)]
                                                   r$impact <- e
                                                 }
                                               }
                                               return(r)
                                             }))
                              }))

  colnames(fres) <- c(
     "uuid", "query", "beuuid", "reference", "intersection",
     "p-value", "FDR", "value", "group", "impact"
  )
  fres$direct <- TRUE
  fres <- do.call(rbind, by(
     fres,
     fres$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  rownames(fres) <- NULL
  tfregulators <- fres
}
```


```{r}
toShow <- tfregulators %>%
  # left_join(listBEIDs(uuids = unique(tfregulators$beuuid)) %>% select(uuid, value),
  #           by = c("beuuid" = "uuid")) %>% 
  as_tibble() %>% 
  filter(FDR <= 0.05) %>%
  rename(regulatorID = value) 
geneDescr <- getBeIdDescription(unique(toShow$regulatorID), be = "Object", 
                                source = "MetaBase_object", organism = "human")

toShow_tf <- toShow %>%
  mutate(RegSymbol = geneDescr$symbol[match(regulatorID, geneDescr$id)]) %>%
  mutate(Regulator = paste0(sprintf('<a href="%s" target="_blank">%s</a>',
                                    getBeIdURL(regulatorID, databases = "MetaBase_object"),
                                    RegSymbol)))
```

The predicted regulators include `r length(unique(grep("mir", toShow_tf$RegSymbol, ignore.case = TRUE, value = TRUE)))` miRNA and `r length(unique(grep("mir", toShow_tf$RegSymbol, ignore.case = TRUE, invert = TRUE, value = TRUE)))` transcription binding factors. 

Additional information is available for the regulators on the number of module they are predicted to regulate for each type of impact ("#Modules"). Within each module and impact type, the predicted regulators are clustered to identify regulators sharing downstream targets within the module and impact type. Regulators are clustered together if they share on average 50% of their targets. 

```{r, include= TRUE}
datatable(toShow_tf %>%
            select(Module = uuid,
                  `Module size` = query,
                  Regulator,
                  Effect = impact,
                  Group = group,
                  Subgroup = subgroup,
                  `#Modules`= count,
                  `# Targets` = reference,
                  Intersection = intersection,
                  FDR) %>%
            mutate(Module = as.factor(Module),
                   Effect = as.factor(Effect)), 
          rownames = FALSE,
          filter = "top",
          options = list(order = list(9, "asc"),
                         searchCols = list(NULL, NULL, NULL,
                                           list(search = '["Activation", "Inhibition"]'),
                                           NULL, NULL, NULL),
                         autoWidth = TRUE,
                         columnDefs = list(list(width = '120px', 
                                                targets = c(0, 2)))),
          escape = FALSE) %>%
  formatSignif("FDR", digits = 2)
```


## Cell membrane proteins


```{r}
if(!file.exists(here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))){
  ## + Objects of interest ----
  cmp <- mb.get.icon.objects(
     species="human",
     iconsOfInterest=mb.cellMembrane.icons
  )
  cmp <- as.character(cmp)
  
  ## + Pathways ----
  cmp.p <- getBekInteractions(beidValues=cmp, sources="MetaBase_object")
  cmp <- intersect(cmp, BEIDs(cmp.p)$value)
  
  ## + Keeping available objects only ----
  cmp <- intersect(
     cmp,
     availableObjects$conv.from[which(availableObjects$available.o)]
  )
  cmp.fp <- filterByBEID(
     cmp.p,
     availableObjects$conv.from[which(availableObjects$available.o)],
     field="value"
  )
  
  ## + Filtering interactions of interest ----
  cmp.fp <- filterByInteraction(
     cmp.fp,
     mb.transduction.mechanisms,
     field="type"
  )
  cmp.fp.mm <- filterByInteraction(
     cmp.fp,
     "Homo sapiens",
     field="organism"
  )
  cmp.fp.any <- filterByInteraction(
    cmp.fp,
    "any",
    field="organism"
  )
  iToTake <- unique(unlist(lapply(cmp.fp.mm, function(x)x$uuid)))
  eimm <- unique(unlist(lapply(cmp.fp.mm, function(x)x$externalID)))
  iToTake <- c(
    iToTake,
    unique(unlist(lapply(
      cmp.fp.any,
      function(x) x$uuid[which(!x$externalID %in% eimm)]
    )))
  )
  cmp.fp <- filterByInteraction(
    cmp.fp,
    iToTake,
    field="uuid"
  )
  
  ## + Get linear pathways ----
  cmpuuid <- listBEIDs(
     values=cmp, be="Object", sources="MetaBase_object", organisms="any"
  )
  fromObjects <- intersect(
     cmpuuid$uuid,
     unique(unlist(lapply(cmp.fp, function(x) x$from)))
  )
  toObjects <- intersect(tr$uuid, BEIDs(cmp.fp)$.uuid)
  lp <- getLinearPathways(
     interactionList=cmp.fp,
     fromIds=fromObjects,
     toIds=toObjects,
     mc.cores=20
  )
}
```

```{r}
if(!file.exists(here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))){
  ## + Indirect targets of objects of interest ----
  utfByUpstream <- lp$impact
  irTargetsDf <- merge(
     utfByUpstream,
     trTargetsDf,
     by.x="to", by.y="from"
  )
  irTargetsDf$impact <- ifelse(
     irTargetsDf$impact.x=="Activation",
     ifelse(
        irTargetsDf$impact.y=="Activation",
        "Activation",
        ifelse(
           irTargetsDf$impact.y=="Inhibition",
           "Inhibition",
           "Unspecified"
        )
     ),
     ifelse(
        irTargetsDf$impact.x=="Inhibition",
        ifelse(
           irTargetsDf$impact.y=="Activation",
           "Inhibition",
           ifelse(
              irTargetsDf$impact.y=="Inhibition",
              "Activation",
              "Unspecified"
           )
        ),
        "Unspecified"
     )
  )
  toAdd <- irTargetsDf[
     which(irTargetsDf$impact %in% c("Activation", "Inhibition")),
     ]
  toAdd$impact <- "Unspecified"
  irTargetsDfd <- rbind(irTargetsDf, toAdd)
  irTargets <- lapply(
     split(irTargetsDfd, irTargetsDfd$impact),
     function(x){
        toRet <- lapply(
           split(x, x$from),
           function(y){
              y$value
           }
        )
        scope <- as.list(unique(x[,c("be", "source", "organism.x")]))
        names(scope) <- c("be", "source", "organism")
        md <- cmpuuid[match(names(toRet), cmpuuid$uuid),]
        rownames(md) <- md$uuid
        return(BEIDList(
           l=toRet,
           metadata=md,
           scope=scope
        ))
        return(toRet)
     }
  )
  irTargets <- lapply(
     irTargets,
     focusOnScope,
     force=TRUE,
     be="Gene", source="Ens_gene", organism="human"
  )
  
  ## + Enrichment analysis ----
  res <- lapply(
     irTargets,
     function(x){
       qrlEnrich(
         reference=x,
         query=toTest,
         omega=expressedGenes,
         mc.cores=30
       )
     }
  )
  cr_cmp_res <- res
  
  ## Add grouping of regulators within each module/impact (regulators are grouped together when they share at least 50% of their targets)
  fres <- lapply(res,
                 function(t){
                   t %>%
                     filter(FDR <= 0.05)
                 })
  fres <- do.call(rbind,
                     lapply(names(toTest),
                            function(m){
                              do.call(rbind,
                                      lapply(names(fres),
                                             function(e){
                                               r <- fres[[e]] %>%
                                                 filter(q == m) %>%
                                                 mutate(value = listBEIDs(uuids = r)$value) %>%
                                                 arrange(FDR)
                                               if(!is.null(r) & nrow(r) > 0){
                                                 if(nrow(r) == 1){
                                                   r$group <- 1
                                                   r$impact <- e
                                                 }else{
                                                   reg <- apply(r, 1,
                                                                function(x){intersect(toTest[[m]],
                                                                                      irTargets[[e]][[x[3]]])
                                                   })
                                                   names(reg) <- pull(r, `value`)
                                                   groups <- lgrouping(reg, distMeth = "jaccard",
                                                                       hcMeth = "average")
                                                   r$group <- groups[as.character(r$value)]
                                                   r$impact <- e
                                                 }
                                               }
                                               return(r)
                                             }))
                              }))
  
  colnames(fres) <- c(
     "uuid", "query", "beuuid", "reference", "intersection",
     "p-value", "FDR", "value", "group", "impact"
  )
  
  fres$direct <- FALSE
  fres <- do.call(rbind, by(
     fres,
     fres$uuid,
     function(d){
        d$rank <- rank(-log10(d$"p-value"))
        d$relRank <- d$rank/max(d$rank, na.rm=TRUE)
        return(d)
     }
  ))
  
   ##########################################@
  ## Target subgroups
  ## Identify subgroups, when more than 50 targets are allocated to a target group
  subgr <- fres %>%
    group_by(uuid, impact) %>%
    add_count(group) %>%
    filter(n > 50) %>%
    ungroup()
  if(nrow(subgr) > 0){
    reg <- plyr::compact(sapply(unique(subgr$uuid),
                                function(m){
                                  plyr::compact(sapply(
                                    unique(subgr$impact),
                                    function(i){
                                      toRet <- apply(subgr %>% filter(uuid == !!m & impact == !!i), 1,
                                                     function(x){
                                                       toRet <- intersect(moduleList[[x["uuid"]]],
                                                                          irTargets[[x["impact"]]][[x["beuuid"]]])
                                                       return(toRet)
                                                     })
                                      if(!is.null(toRet)){
                                        names(toRet) <- subgr %>%
                                          filter(uuid == !!m & impact == !!i) %>%
                                          pull(value)
                                      }
                                      return(toRet)
                                    }, USE.NAMES = TRUE, simplify = FALSE))
                                }, USE.NAMES = TRUE, simplify = FALSE))
    groups <- do.call(rbind, sapply(names(reg),
                                    function(m){
                                      do.call(rbind, sapply(names(reg[[m]]),
                                                            function(i){
                                                              toRet <- lgrouping(reg[[m]][[i]], sharing = 0.7, distMeth = "jaccard")
                                                              toRet <- as_tibble(toRet, rownames = NA) %>%
                                                                mutate_all(~letters[.]) %>%
                                                                rownames_to_column() %>%
                                                                mutate(impact = i,
                                                                       module = m) %>%
                                                                rename(subgroup = value)
                                                            }, USE.NAMES = TRUE, simplify = FALSE))
                                    }, USE.NAMES = TRUE, simplify = FALSE))
    fres <- fres %>%
      left_join(groups , by = c("uuid" = "module", "impact", "value" = "rowname"))
  }else{
    fres <- fres %>% 
      mutate(subgroup = NA)
  }
  
  ## Module under regulation
  cnt <- fres %>% group_by(impact) %>% count(value, name = "count")
  fres <- fres %>%
    left_join(cnt,
              by = c("value", "impact"))
  
  rownames(fres) <- NULL
  cmpregulators = fres
  
  save(trTargets, irTargets, irTargetsDfd, tfregulators, cmpregulators,
       cr_cmp_res, cr_tf_res, cmp.fp, dlp,
       file = here("Data/07_CausalReasoning/FCD2b_regulators_lp.rda"))
}
```



```{r, include = FALSE}
toShow <- cmpregulators %>%
  as_tibble() %>% 
  filter(FDR <= 0.05) %>%
  rename(regulatorID = value) 
geneDescr <- getBeIdDescription(unique(toShow$regulatorID), be = "Object", 
                                source = "MetaBase_object", organism = "human")
toShow_cmp <- toShow %>%
  mutate(RegSymbol = geneDescr$symbol[match(regulatorID, geneDescr$id)]) %>%
  mutate(Regulator = paste0(sprintf('<a href="%s" target="_blank">%s</a>',
                                    getBeIdURL(regulatorID, databases = "MetaBase_object"),
                                    RegSymbol))) %>% 
    mutate(pathway = paste0(sprintf('<a href="https://portal.genego.com/cgi/imagemap.cgi?id=%s" target="_blank">%s</a>',
                                    pathwayId,
                                    pathway)))
```

The predicted regulators include `r length(unique(toShow_cmp$RegSymbol))` cell membrane proteins. Additional information is available for the regulators on the number of module they are predicted to regulate for each type of impact ("#Modules"). Within each module and impact type, the predicted regulators are clustered to identify regulators sharing downstream targets within the module and impact type. Regulators are clustered together if they share on average 50% of their targets. 

```{r, include = TRUE}
datatable(toShow_cmp %>%
            select(Module = uuid,
                  `Module size` = query,
                  Regulator,
                  Effect = impact,
                  Group = group,
                  Subgroup = subgroup,
                  `#Modules`= count,
                  `# Targets` = reference,
                  Intersection = intersection,
                  FDR)  %>%
            mutate(Module = as.factor(Module),
                   Effect = as.factor(Effect)) %>% 
            distinct(), 
          rownames = FALSE,
          filter = "top",
          options = list(order = list(9, "asc"),
                         searchCols = list(NULL, NULL, NULL,
                                           list(search = '["Activation", "Inhibition"]'),
                                           NULL, NULL, NULL),
                         autoWidth = TRUE,
                         columnDefs = list(list(width = '120px', 
                                                targets = c(0, 2)))),
          escape = FALSE) %>%
  formatSignif(10, digits = 2)
```


# Conclusion

Within patients diagnosed with FCD 2b 21 modules were identified containing 9,928 genes. No association was detected between any of the modules and the recorded phenotypes. 

Functional annotation identified three general groups among the modules (neuronal function, immune response, and general cell function). In addition, the enrichment of modules for specific brain cell types (neurons, microglia, astrocytes, oligodendrocytes, and granulocytes) was performed although modules can exhibit multiple types. The functional annotation can help to increase understanding of the module biological function it can also aid to prioritize modules for target discovery.

Finally, the causal reasoning identified both direct (transcription factors and miRNA) regulators as well as indirect (cell membrane proteins) regulators using canonical linear pathways. While the majority of transcription factors were predicted to specifically regulate modules, the large majority of miRNAs shows a strong unspecific regulation of modules. This can potentially be improved by filtering only the expressed miRNAs within the dataset. 
